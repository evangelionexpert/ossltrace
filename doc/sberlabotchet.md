# Отчет по ossltrace

## 1. Титульник
тот-то тот то такой то проект

## 2. Актуальность
Внедрение https ведется семимильными шагами. Согласно [анонимной статистике, собираемой с пользователей Google Chrome](https://transparencyreport.google.com/https/overview), на момент декабря 2023 г. от 87% до 97% посещаемых вебстраниц (в зависимости от страны) загружается по https. Данный протокол, используя TLS или - ранее - SSL шифрование, позволяет обеспечить безопасный обмен трафиком между клиентом и сервером, значительно усложняя перехват или подмену данных. 

## 3/4. Проблема, решение
Впрочем, возникает сопутствующая шифрованию проблема - усложнение анализа трафика и его фильтрации/кэширования. 
Для решения проблемы предлагается найти способы взаимодействия с зашифрованным трафиком.

## 5. Новизна
Обычно, работать с зашифрованным трафиком можно двумя способами:
- перехватить ключи от сессии, потом смотреть трафик в Wireshark и т.п.
- общаться с сервером через прокси (как вариант - squid?, Burpsuite) с "промежуточным" сертификатом

Первый вариант годится исключительно для исследовательских целей, второй же требует вмешательства пользователя в работу анализируемого приложения (нужно явно настроить приложение для работы с прокси-сервером и добавить его сертификаты в списки доверенных). Данная работа предлагает использовать механизм перехвата вызовов библиотек, предоставляющих возможности сетевого взаимодействия с SSL/TLS шифрованием.

## 6. Практическая ценность
В чем преимущество подхода с перехватом вызовов процесса? 
- легкая интеграция в сложную сетевую инфраструктуру (в случае необходимости оперировать сегментами, которые принимал/отправлял процесс по SSL)
- можно использовать как хотфикс (ограничить доступ к уязвимому ресурсу, запретить использовать какие-то хэдеры и т.п.)
- не требуется никакого самостоятельного взаимодействия с сетевыми устройствами, так что и административных привилегий для функционирования не нужны

## 7. Цель
Цель работы: разработка приложения для ОС Linux, перехватывающего вызовы библиотек, осуществляющих сетевое взаимодействие с SSL/TLS шифрованием.

## 8. Задачи/реализация
## 8.1. Анализ предметной области
На сегодняшний день наиболее распространенной SSL/TLS библиотекой является OpenSSL. Она используется в Firefox, curl, а что наиболее важно для данной работы - двух наиболее популярных веб-серверах, nginx и apache2. Таким образом, на данный момент было решено ограничиться работой с единственной библиотекой. 

Стоит упомянуть, что в среде информационной безопасности считается хорошим тоном линковать OpenSSL динамически, ибо такой подход предоставляет возможность оперативно обновить OpenSSL независимо от самого приложения в случае возникновения критических уязвимостей; таким образом, задача перехвата вызовов (которые, очевидно, не системные) многократно упрощается.

## 8.2. Описание функционала
В текущей версии доступен следующий функционал:
- непосредственно, перехват некоторых вызовов OpenSSL пока что тремя разными способами
- логгирование
- простейший фильтр
- отключение верификации цепочки доверия сертификатов

## 8.3. Перехват
Утилита может работать в 3 режимах перехвата:

### 8.3.1. LD_PRELOAD
Самый простой и известный способ перехвата вызовов. ld.so (системный компоновщик времени исполнения; далее просто линкер) загружает библиотеку, указанную в LD_PRELOAD раньше остальных, и вызывает функцию из этой библиотеки вместо функции из - в данном случае - libssl.so, если названия символов совпадают. При использовании данного метода не предоставляется возможным адекватно перехватывать вызовы dlopen() - кроме как через dlvsym(), т.е. версионированный dlsym(), что весьма специфично - поскольку они используются для получения адреса символа из оригинальной библиотеки.

### 8.3.2. LD_AUDIT
Удобный API для анализа не-системных (хотя и их тоже) вызовов; например, им пользуется небезызвестная утилита latrace.
Главный интерес предоставляют: 
- la_objopen(). Линкер вызывает эту функцию после того, как была загружена новая динамическая библиотека (shared object). В качестве возвращаемого значения можно указать LA_FLG_BINDTO - тогда при вызове функций из этой библиотеки будет уведомлена audit library (перевод?).
```
la_objopen(obj) {
    if (obj == 'libssl.so')
        return LA_FLG_BINDTO
    else 
        return 0
}
```

- la_symbind*(), вызываемая в audit либе (перевод?) в момент привязки символов. В качестве возвращаемого значения можно указать адрес подменяющего символа, а в аргументах представлена структура исходного символа, включающая его адрес и наименование. Работает и с dlopen(), и с ленивой линковкой (-z lazy), и с линковкой в момент запуска программы (-z now/LD_BIND_NOW).
```
la_symbind(sym) {
    if (sym->symname == 'SSL_write')
        orig_SSL_write = sym->st_value
        return hooked_SSL_write
    else if (...) 
        ...
}
```

К большому сожалению, данный механизм работает только при наличии PLT записей. Если же целевая программа была скомпилированна с флагом -fno-plt (для gcc), например, в целях оптимизации, la_symbind() перестает работать. В процессе поиска информации был найден [патч](https://sourceware.org/pipermail/libc-alpha/2021-October/131954.html), в том числе позволяющий упомянутой функции корректно работать без PLT записей, однако он все еще не является частью glibc (на момент декабря 2023?, glibc2.38).

Достоин упоминания тот факт, что, в частности, в репозиториях дистрибутива Arch Linux почти все - [за крайне редким исключением](https://github.com/search?q=repo%3Aarchlinux%2Fsvntogit-packages+%22-fno-plt%22&type=code) - программы компилируются с флагом -fno-plt, а в официальных репозиториях дистрибутива Ubuntu, хотя это и не является стандартным поведением, nginx компилируется с -fno-plt. 

Подробнее: man rtld-audit(7)

### 8.3.3. Наивный динамический патчинг


```
# Исходник SSL_write

SSL_write + 0x00 | endbr64
SSL_write + 0x04 | sub rsp, 18h
SSL_write + 0x08 | mov rax, fs:28h
SSL_write + 0x11 | xor eax, eax
SSL_write + 0x16 | test edx, edx
SSL_write + 0x.. | ...
```

```
# SSL_write с прыжком в хук

SSL_write + 0x00 | endbr64
SSL_write + 0x04 | jmp QWORD PTR hooked_fun 
SSL_write + 0x12 | endbr64
SSL_write + 0x16 | test edx, edx
SSL_write + 0x.. | ...
```

```
# Новая функция в динамически аллоцированной памяти.
# состоит из начала исходной SSL_write 
# и прыжка на продолжение SSL_write

orig_func + 0x00 | endbr64
orig_func + 0x04 | sub rsp, 18h
orig_func + 0x08 | mov rax, fs:28h
orig_func + 0x11 | xor eax, eax
orig_func + 0x16 | jmp QWORD PTR SSL_write+0x12
```


## 8.4. Логгирование


## 8.5. Фильтрация

## 8.6. Отключение цепочки доверия

## 9. Планы
- "умный" патчинг с дизассемблером (capstone)
- обработка SSL_get_error: на данный момент из SSL_read/write возвращается -1, но код ошибки 0
- "сборка" частей сегмента в единый сегмент (SSL_pending)
- поскольку можно будет восстановить полный сегмент, реализовать более комплексный и сложный фильтр
- фильтр для http/2
- изучить тему eBPF (enchanced Beckerley Packet Filter) - вроде можно перехватывать без костылей, надо удостовериться в том, что производительность падает незначительно
- попробовать подменять ld.so 
