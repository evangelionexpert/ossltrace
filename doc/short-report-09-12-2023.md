# Отчет по ossltrace

## 1. Титульник
тот-то тот то такой то проект

## 2. Актуальность
Внедрение https ведется семимильными шагами. Согласно [анонимной статистике, собираемой с пользователей Google Chrome](https://transparencyreport.google.com/https/overview), на момент декабря 2023 г. от 87% до 97% посещаемых вебстраниц (в зависимости от страны) загружается по https. Данный протокол, используя TLS или - ранее - SSL шифрование, позволяет обеспечить безопасный обмен трафиком между клиентом и сервером, значительно усложняя перехват или подмену данных. 

## 3/4. Проблема, решение
Впрочем, возникает сопутствующая шифрованию проблема - усложнение анализа трафика, в том числе его фильтрации.
Для решения проблемы предлагается найти способы взаимодействия с зашифрованным трафиком.

## 5. Новизна
Обычно, работать с зашифрованным трафиком можно двумя способами:
- перехватить ключи от сессии, потом смотреть трафик в Wireshark и т.п.
- общаться с сервером через прокси (как вариант - squid?, Burpsuite) с "промежуточным" сертификатом

Первый вариант годится преимущественно для исследовательских целей, второй же требует вмешательства пользователя в работу анализируемого приложения. Данная работа предлагает использовать механизм перехвата вызовов библиотек, предоставляющих возможности сетевого взаимодействия с SSL/TLS шифрованием.

## 6. Практическая ценность
В чем преимущество подхода с перехватом вызовов процесса? 
- легкая интеграция в сложную сетевую инфраструктуру (в случае необходимости оперировать сегментами, которые принимал/отправлял процесс по SSL)
- можно использовать как хотфикс (ограничить доступ к уязвимому ресурсу, запретить использовать какие-то хэдеры и т.п.)
- не требуется никакого самостоятельного взаимодействия с сетевыми устройствами, так что и административные привилегии для функционирования не нужны
- околонативная производительность

## 7. Цель
Цель работы: разработка приложения для ОС Linux, перехватывающего вызовы библиотек, осуществляющих сетевое взаимодействие с SSL/TLS шифрованием.

## 8. Задачи + что сделано 
В текущей версии доступен следующий функционал:
- непосредственно, перехват некоторых вызовов OpenSSL пока что тремя разными способами
- логгирование
- простейший фильтр
- отключение верификации цепочки доверия сертификатов

## 8.2. Анализ предметной области
На сегодняшний день наиболее распространенной SSL/TLS библиотекой является OpenSSL. Она используется в Firefox, curl, а что наиболее важно для данной работы - двух наиболее популярных веб-серверах, nginx и apache2. Таким образом, на данный момент было решено ограничиться работой с единственной библиотекой. 

Стоит упомянуть, что в среде информационной безопасности считается хорошим тоном линковать OpenSSL динамически, ибо такой подход предоставляет возможность оперативно обновить OpenSSL независимо от самого приложения в случае возникновения критических уязвимостей; то есть, задача перехвата вызовов (не системных) многократно упрощается.

## 8.3. Перехват
Утилита может работать в 3 режимах перехвата, каждый из которых может лучше подойти для конкретного приложения.

### 8.3.1. LD_PRELOAD
Самый простой и известный способ перехвата вызовов. ld.so (системный компоновщик времени исполнения; далее просто линкер) загружает библиотеку, указанную в LD_PRELOAD раньше остальных, и вызывает функцию из этой библиотеки вместо функции из - в данном случае - libssl.so, если названия символов совпадают. К сожалению, при использовании данного метода не предоставляется возможным адекватно перехватывать вызовы dlsym().

### 8.3.2. rtld-audit
Удобный API, предоставляющий набор прототипов функций, которые вызываются линкером при выполнении определенных операций; эти функции можно определить в соответствии с желаемым поведением линкера и подопытной программы.
Главный интерес предоставляют следующие функции: la_objopen() и la_symbindXX().

```C
la_objopen(obj) {
    if (obj == 'libssl.so')
        return LA_FLG_BINDTO
    else 
        return 0
}
```

```C
la_symbindXX(sym) {
    if (sym->symname == 'SSL_write')
        orig_SSL_write = sym->st_value
        return hooked_SSL_write
    else if (...) 
        ...
}
```

К большому сожалению, данный механизм полностью правильно работает только при наличии PLT записей, вероятно - из-за [особенности/бага в glibc](https://sourceware.org/pipermail/libc-alpha/2021-October/131954.html). Если же целевая программа была скомпилированна с флагом -fno-plt (для gcc), например, в целях оптимизации, la_symbindXX() перестает работать. 

### 8.3.3. Наивный динамический патчинг
Данный метод во время исполнения изменяет код функций SSL, делая jmp на подменяющую функцию в начале исполнения оригинальной. Можно и восстановить оригинальную функцию, скопировав её начало в динамический буфер, из которого будет делаться jmp на неперезаписанное продолжение оригинальной функции. Метод зависим от конкретного машинного представления кода каждой функции.

```
# Исходник SSL_write

SSL_write + 0x00 | endbr64
SSL_write + 0x04 | sub rsp, 18h
SSL_write + 0x08 | mov rax, fs:28h
SSL_write + 0x11 | xor eax, eax
SSL_write + 0x16 | test edx, edx
SSL_write + 0x.. | ...
```

```
# SSL_write с прыжком в хук

SSL_write + 0x00 | endbr64
SSL_write + 0x04 | jmp QWORD PTR hooked_fun+0x00
SSL_write + 0x12 | endbr64
SSL_write + 0x16 | test edx, edx
SSL_write + 0x.. | ...
```

```
# Новая функция в динамически аллоцированной памяти.
# состоит из начала исходной SSL_write 
# и прыжка на продолжение SSL_write

orig_func + 0x00 | endbr64
orig_func + 0x04 | sub rsp, 18h
orig_func + 0x08 | mov rax, fs:28h
orig_func + 0x11 | xor eax, eax
orig_func + 0x16 | jmp QWORD PTR SSL_write+0x12
```


## 8.4. Логгирование
Для осуществления журналирования используются следующие самописные макросы:
```C
OSSLTRACE_LOG(format, va_args..)
OSSLTRACE_LOG_BUF(buf, bufsize)
```

Может производиться как в стандартные потоки вывода (stdout/stderr), так и в файл, в зависимости от настроек пользователя. 

## 8.5. Фильтрация
Пока что фильтрация осуществляется в соответствии со списком строк, разделенных символом переноса строки; функция фильтрации ищет в передаваемом буфере одну из этих строк; если хоть одна из строк нашлась - возвращается указатель на начало найденной zero-terminated строки.

```C
char *
find_denylisted_words_occurence(const void *buf, int bufsize);
```

## 8.6. Отключение верификации цепочки доверия
Для отключения верификации цепочки доверия перехватываются вызовы SSL_set_verify() и SSL_get_verify_result(). В первом выставляем SSL_VERIFY_NONE; во втором всегда возвращаем X509_OK.

## 9. Планы
Перехват: 
- "умный" универсальный патчинг с дизассемблером (capstone)
- изучить тему eBPF (enchanced Beckerley Packet Filter)
- смешанные режимы перехвата

Подменяющие функции:
- обработка SSL_get_error: из SSL_read/write возвращается -1, но код ошибки 0; нужно исправить
- "сборка" частей сегмента в единый сегмент (SSL_pending)
- поскольку можно будет восстановить полный сегмент, реализовать более комплексный и сложный фильтр, в т.ч. для конкретных протоколов
- фильтр для http/2

Прочее:
- передача настроек не через переменные окружения (nginx их очищает)
- сомнительно, но gnutls и другие библиотеки
- поддержка незашифрованных соединений (обычные read, write и т.п.)
