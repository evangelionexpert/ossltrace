# Отчет по ossltrace

## 1. Титульник
Всем доброго дня. Хочу представить вам результат семестровой работы над созданием ossltrace - инструмента для перехвата и фильтрации SSL/TLS трафика в рамках процесса. Выполнил работу Смоляков Павел, мой руководитель - Лебедев Роман.

## 2. Актуальность
Внедрение https ведется семимильными шагами. Согласно [статистике, собираемой с пользователей Google Chrome](https://transparencyreport.google.com/https/overview), на сегодняшний день от 88% до 98% посещаемых вебстраниц (в зависимости от страны) загружается по https. 

*слайд* 

Данный протокол, используя TLS или - ранее - SSL шифрование, позволяет обеспечить безопасный обмен трафиком между клиентом и сервером, значительно усложняя перехват или подмену данных. 

## 3/4. Проблема, решение
Впрочем, возникает сопутствующая шифрованию проблема - усложнение анализа трафика, в том числе его фильтрации.

*слайд* 

Для решения проблемы предлагается найти способы взаимодействия с зашифрованным трафиком.

## 5. Новизна
Обычно, работать с зашифрованным трафиком можно двумя способами:
- перехватить ключи от сессии, потом смотреть трафик в Wireshark и подобных программах
- общаться с сервером через прокси с "промежуточным" сертификатом

Первый вариант годится преимущественно для исследовательских целей, второй же требует вмешательства пользователя в работу анализируемого приложения. В данной работе предлагается использовать механизм перехвата вызовов библиотек, предоставляющих возможности сетевого взаимодействия с SSL/TLS шифрованием.

## 6. Практическая ценность
В чем преимущество подхода с перехватом вызовов процесса? 
- легкая интеграция в сложную сетевую инфраструктуру 
- можно использовать как хотфикс (ограничить доступ к уязвимому ресурсу, запретить использовать какие-то хэдеры и т.п.)
- не требуется никакого самостоятельного взаимодействия с сетевыми устройствами, так что и административные привилегии для функционирования не нужны
- отсутствие потерь производительности

## 7. Цель
Цель работы: разработка приложения для ОС Linux, перехватывающего вызовы библиотек, осуществляющих сетевое взаимодействие с SSL/TLS шифрованием.

## 8. Задачи (что сделано)
На данный момент уже сделаны:
- анализ предметной области
- изучение и применение пока что трёх механизмов перехвата вызовов 
- разработка архитектуры приложения
- журналирование
- реализация фильтра
- отключение верификации цепочки доверия сертификатов

## 8.1. Анализ предметной области
На сегодняшний день наиболее распространенной SSL/TLS библиотекой является OpenSSL. Она используется в Firefox, curl, а что наиболее важно для данной работы - двух наиболее популярных веб-серверах, nginx и apache2. Таким образом, на данный момент было решено ограничиться работой с единственной библиотекой. 

Стоит упомянуть, что вообще считается хорошим тоном линковать OpenSSL динамически, ибо такой подход предоставляет возможность оперативно обновить OpenSSL независимо от самого приложения в случае возникновения критических уязвимостей; то есть, задача перехвата вызовов (не системных) упрощается.

## 8.2. Библиотека.
Для лучшего понимания материала на всякий случай вспомним, как в принципе может осуществляться взаимодействие с внешними библиотеками.

Статические библиотеки, обычно с расширением .a, представляют собой по сути архив объектных файлов. В процессе компоновки получается один самодостаточный исполняемый файл,у которого нет зависимостей от внешних библиотек.

*слайд*

С другой стороны, динамические (разделяемые) библиотеки (.so) подключаются в ходе исполнения или при запуске приложения. Обращение к системному компоновщику времени исполнения (ld.so) происходит либо когда встречается неразрешенный символ (умышленно оставленный линкером при сборке программы), либо при подключении библиотеки через dlopen() при непосредственно выполнении программы. 


## 8.3. Перехват
На данный момент утилита может работать в 3 режимах перехвата, каждый из которых может лучше подойти для конкретного приложения.

### 8.3.1. LD_PRELOAD
Начнем с LD_PRELOAD. Это самый простой и известный способ перехвата вызовов. ld.so загружает библиотеку, указанную в LD_PRELOAD раньше остальных, и вызывает функцию из этой библиотеки вместо функции из - в данном случае - libssl.so, если названия символов совпадают. 

*слайд*

К сожалению, при использовании данного метода не предоставляется возможным адекватно и удобно перехватывать вызовы dlsym() - существует, конечно, способ с dlvsym(), способным найти символ из glibc конкретной версии, однако ввиду странности и неочевидности версионирования в glibc этот способ сложно назвать предпочтительным. Посему рассмотрим иные подходы.

### 8.3.2. rtld-audit
Такие, как, например, rtld-audit. Это мощный и удобный API для аудита, предоставляемый компоновщиком времени исполнения и являющийся набором прототипов функций, которые вызываются линкером при выполнении некоторых связанных с ним операций; эти функции можно определить в соответствии с желаемым поведением линкера и подопытной программы.
Главный интерес предоставляют следующие две функции:
la_objopen() - линкер вызывает её после того, как была загружена новая динамическая библиотека (shared object) и la_symbindXX(), вызываемая в осуществляющей аудит библиотеке в момент привязки символов.


```C
la_objopen(obj) {
    if (obj == 'libssl.so')
        return LA_FLG_BINDTO
    else 
        return LA_FLG_BINDFROM
}
```

```C
la_symbindXX(sym) {
    if (sym->symname == 'SSL_write')
        orig_SSL_write = sym->st_value
        return hooked_SSL_write
    else if (...) 
        ...
}
```

К большому сожалению, данный механизм полностью правильно работает только при наличии PLT записей (необходимых для позднего связывания) в скомпилированном коде, вероятно - из-за [особенности/бага в glibc](https://sourceware.org/pipermail/libc-alpha/2021-October/131954.html). Если же целевая программа была скомпилированна с флагом -fno-plt (для gcc), например, в целях оптимизации, la_symbindXX() перестает работать. 

### 8.3.3. Наивный динамический патчинг
Данный метод во время исполнения изменяет код функций SSL: делаем jmp на хук при вызове оригинальной функции. Оригинальную функцию восстановим, скопировав ее начало в динамический буфер и прыгнув на нетронутое продолжение оригинальной функции.
Метод зависим от конкретного машинного представления кода каждой функции.

** слайды **
 
Собственно, схема с предыдущего слайда чуть упрощена: в реальности не всегда можно поменять начало функции, так как удаление инструкции endbr64 сломает прыжки на функцию по смещению (но не по абсолютному адресу) на процессорах Intel начиная с 11 поколения ввиду новых механизмов безопасности (Control-Flow Enforcement). Чтобы вставить прыжок на функцию-хук нужно 6 байт на саму инструкцию и еще 8 на операнд, к счастью, в SSL_read и write достаточно инструкций, которые можно без проблем скопировать и выполнить потом.


```
# Исходник SSL_write

SSL_write + 0x00 | endbr64
SSL_write + 0x04 | sub rsp, 18h
SSL_write + 0x08 | mov rax, fs:28h
SSL_write + 0x11 | xor eax, eax
SSL_write + 0x16 | test edx, edx
SSL_write + 0x.. | ...
```

```
# SSL_write с прыжком в хук

SSL_write + 0x00 | endbr64
SSL_write + 0x04 | jmp QWORD PTR hooked_fun+0x00
...
SSL_write + 0x16 | test edx, edx
SSL_write + 0x.. | ...
```

```
# Новая функция в динамически аллоцированной памяти.
# состоит из начала исходной SSL_write 
# и прыжка на продолжение SSL_write

orig_func + 0x00 | endbr64
orig_func + 0x04 | sub rsp, 18h
orig_func + 0x08 | mov rax, fs:28h
orig_func + 0x11 | xor eax, eax
orig_func + 0x16 | jmp QWORD PTR SSL_write+0x12
```

## 8.3.4. eBPF.
Все три упомянутых метода уже проверены в работе. Однако, есть и другие варианты. eBPF или расширенный пакетный фильтр Бекереля является расширением инструмента BPF, с прошлого столетия используемого для анализа сетевого трафика в ОС Linux. BPF предоставляет грубый интерфейс для обработки сетевых пакетов между всеми сетевыми устройствами. В то же время расширенный вариант инструмента позволяет решать более сложные задачи, в том числе - есть возможность перехватывать нужные нам вызовы, причем в рамках всей системы, а не процесса.

Вместе с тем, в рамках нашей задачи это избыточно: (e)bpf-программы запускаются в пространстве ядра, что уже требует определенных пользовательских привилегий и ухудшает производительность (прелоад, аудит, патчинг работают с нативной производительностью, тут же начинаются переключения контекста и прочие радости жизни).

Таким образом, реализация не планируется.



## 8.4. Логгирование

Удобно, если, к примеру, в вызовах, связанных с чтением/записью, в логах запечатлевается содержимое сегмента.

В данной утилите для осуществления журналирования используются следующие самописные макросы:
```C
OSSLTRACE_LOG(format, va_args..)
OSSLTRACE_LOG_BUF(buf, bufsize)
```

Может производиться как в стандартные потоки вывода (stdout/stderr), так и в файл, в зависимости от настроек пользователя. 

## 8.5. Фильтрация
Пока что фильтрация осуществляется в соответствии с предоставленным пользователем списком строк; функция фильтрации ищет в передаваемом буфере вхождения этих строк и возвращает указатель на первое попавшееся вхождение.


```C
char *
find_denylisted_words_occurence(const void *buf, int bufsize);
```

## 8.6. Отключение верификации цепочки доверия сертификата
Иногда может пригодиться возможность использовать самоподписанный сертификат, при этом хотелось бы отключить предупреждения клиентских приложений о отсутствии подписи удостоверяющего центра.
Для реализации перехватываются вызовы SSL_set_verify() и SSL_get_verify_result().

## 8.7. Архитектура
В результате превращения всего вышесказанного в код, получилось вот такое вот приложение. Один из наиболее подходящих языков для реализации подобных вещей - обыкновенный Си; он и был выбран.

## Демо
1. Демонстрируется работа просто курла.
2. Демонстрируется блеклист.

## Результат
Говоря коротко, в результате все поставленные задачи успешно решены.

## Публикации
Некоторые перешедшие в данный проект наработки из схожей работы с Летней школы 2023 года о перехвате в тот раз системных вызовов были представлены мной на конференциях ЗОНТ и Мальцевские чтения, а по текущему - планируется выступление на МНСК. 

## 9. Планы
Перехват: 
- "умный" универсальный патчинг с дизассемблером (capstone) - то есть, будет существовать некоторый алгоритм, самостоятельно оценивающий возможность патчинга и производящий его в соответствии с актуальным бинарным представлением функции уже после загрузки библиотеки
- смешанные режимы перехвата

Подменяющие функции:
- "сборка" частей сегмента в единый сегмент (SSL_pending)
- поскольку можно будет восстановить полный сегмент, реализовать более комплексный и сложный фильтр, в т.ч. для конкретных протоколов
- фильтр для http/2

Прочее:
- решить проблему с очисткой пользовательских параметров в некоторых приложениях при вызове execve 
- поддержка незашифрованных соединений (обычные read, write и т.п.)
