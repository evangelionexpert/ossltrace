# Отчет по ossltrace

## 1. Титульник
тот-то тот то такой то проект

## 2. Актуальность
Внедрение https ведется семимильными шагами. Согласно [анонимной статистике, собираемой с пользователей Google Chrome](https://transparencyreport.google.com/https/overview), на момент декабря 2023 г. от 87% до 97% посещаемых вебстраниц (в зависимости от страны) загружается по https. Данный протокол, используя TLS или - ранее - SSL шифрование, позволяет обеспечить безопасный обмен трафиком между клиентом и сервером, значительно усложняя перехват или подмену данных. 

## 3/4. Проблема, решение
Впрочем, возникает сопутствующая шифрованию проблема - усложнение анализа трафика и его фильтрации/кэширования. 
Для решения проблемы предлагается найти способы взаимодействия с зашифрованным трафиком.

## 5. Новизна
Обычно, работать с зашифрованным трафиком можно двумя способами:
- перехватить ключи от сессии, потом смотреть трафик в Wireshark и т.п.
- общаться с сервером через прокси (как вариант - squid?, Burpsuite) с "промежуточным" сертификатом

Первый вариант годится преимущественно для исследовательских целей, второй же требует вмешательства пользователя в работу анализируемого приложения (нужно явно настроить приложение для работы с прокси-сервером и добавить его сертификаты в списки доверенных). Данная работа предлагает использовать механизм перехвата вызовов библиотек, предоставляющих возможности сетевого взаимодействия с SSL/TLS шифрованием.

## 6. Практическая ценность
В чем преимущество подхода с перехватом вызовов процесса? 
- легкая интеграция в сложную сетевую инфраструктуру (в случае необходимости оперировать сегментами, которые принимал/отправлял процесс по SSL)
- можно использовать как хотфикс (ограничить доступ к уязвимому ресурсу, запретить использовать какие-то хэдеры и т.п.)
- не требуется никакого самостоятельного взаимодействия с сетевыми устройствами, так что и административных привилегий для функционирования не нужны
- нативная производительность. Даже системные вызовы используются только при первом перехвате

## 7. Цель
Цель работы: разработка приложения для ОС Linux, перехватывающего вызовы библиотек, осуществляющих сетевое взаимодействие с SSL/TLS шифрованием.

## 8. Задачи/реализация
Обозначим основные задачи:
1. 

## 8.1. Анализ предметной области
На сегодняшний день наиболее распространенной SSL/TLS библиотекой является OpenSSL. Она используется в Firefox, curl, а что наиболее важно для данной работы - двух наиболее популярных веб-серверах, nginx и apache2. Таким образом, на данный момент было решено ограничиться работой с единственной библиотекой. 

Стоит упомянуть, что в среде информационной безопасности считается хорошим тоном линковать OpenSSL динамически, ибо такой подход предоставляет возможность оперативно обновить OpenSSL независимо от самого приложения в случае возникновения критических уязвимостей; то есть, задача перехвата вызовов (в данном случае не системных) многократно упрощается.

## 8.2. Описание функционала
В текущей версии доступен следующий функционал:
- непосредственно, перехват некоторых вызовов OpenSSL пока что тремя разными способами
- логгирование
- простейший фильтр
- отключение верификации цепочки доверия сертификатов

## 8.3. Перехват
Утилита может работать в 3 режимах перехвата, каждый из которых может лучше подойти для конкретного приложения.

### 8.3.1. LD_PRELOAD
Самый простой и известный способ перехвата вызовов. ld.so (системный компоновщик времени исполнения; далее просто линкер) загружает библиотеку, указанную в LD_PRELOAD раньше остальных, и вызывает функцию из этой библиотеки вместо функции из - в данном случае - libssl.so, если названия символов совпадают. При использовании данного метода не предоставляется возможным адекватно перехватывать вызовы dlsym(), поскольку они используются для получения адреса символа из настоящей библиотеки. Иными словами, внутри подменяемого dlsym() нужно использовать исходный dlsym() для того, чтобы получить исходный dlsym(), что, очевидно, невозможно; можно использовать dlvsym() - версионированный dlsym() - однако это очень неудобно. Посему рассмотрим и другие способы.

### 8.3.2. rtld-audit
Удобный API для анализа в частности не-системных вызовов и не только; им пользуется небезызвестная утилита latrace. Этот API предоставляет набор прототипов функций, которые вызываются линкером при выполнении определенных операций; эти функции можно определить в соответствии с желаемым поведением линкера и подопытной программы.
Главный интерес предоставляют следующие функции: 
- la_objopen(). Линкер вызывает эту функцию после того, как была загружена новая динамическая библиотека (shared object). В качестве возвращаемого значения можно указать LA_FLG_BINDTO - тогда при вызове функций из этой библиотеки будет уведомлена библиотека, осуществляющая аудит.
```C
la_objopen(obj) {
    if (obj == 'libssl.so')
        return LA_FLG_BINDTO
    else 
        return 0
}
```

- la_symbindXX(), вызываемая в осуществляющей аудит библиотеке в момент привязки символов. В качестве возвращаемого значения можно указать адрес подменяющего символа, а в аргументах представлена структура исходного символа, включающая его адрес и наименование. Работает и для функций, получаемых через dlsym(), и с ленивой линковкой (-z lazy), и с линковкой в момент запуска программы (-z now/LD_BIND_NOW).
```C
la_symbindXX(sym) {
    if (sym->symname == 'SSL_write')
        orig_SSL_write = sym->st_value
        return payloaded_SSL_write
    else if (...) 
        ...
}
```

К большому сожалению, данный механизм работает только при наличии PLT записей. Если же целевая программа была скомпилированна с флагом -fno-plt (для gcc), например, в целях оптимизации, la_symbindXX() перестает работать. В процессе поиска информации был найден как минимум один [патч](https://sourceware.org/pipermail/libc-alpha/2021-October/131954.html), в том числе позволяющий упомянутой функции корректно работать без PLT записей, однако он все еще не является частью glibc (на момент декабря 2023, версия 2.38).

В репозиториях дистрибутива Arch Linux почти все программы, [за крайне редким исключением](https://github.com/search?q=repo%3Aarchlinux%2Fsvntogit-packages+%22-fno-plt%22&type=code), компилируются с флагом -fno-plt, а в официальных репозиториях дистрибутива Ubuntu, хотя это и не является стандартным поведением, nginx, допустим, компилируется с -fno-plt. Данные факты свидетельствуют о том, что, в действительности, при всем удобстве rtld-audit, он на текущий момент не может называться универсальным способом перехвата.

Больше подробностей может быть найдено в ```man rtld-audit(7)```.

### 8.3.3. Наивный динам
Данный метод во время исполнения изменяет код функций SSL, делая jmp на подменяющую функцию в начале исполнения оригинальной. Можно и восстановить оригинальную функцию, скопировав её начало в динамический буфер, из которого будет делаться jmp на неперезаписанное продолжение оригинальной функции.

Наивный способ, не анализирующий переписываемый код, а только переписывающий инструкции в соответствии с кодом исходников OpenSSL, корректен только для конкретного листинга в конкретной версии библиотеки и в конкретной функции, а значит в долгой перспективе ненадежен и требует постоянной актуализации; вдруг в новой версии библиотеки компилятор выдаст иные инструкции/операнды - они могут быть разных размеров, и часть инструкций/операндов будут перезаписаны наполовину, что почти наверное приведет к абсолютно нерабочему коду.

```
# Исходник SSL_write

SSL_write + 0x00 | endbr64
SSL_write + 0x04 | sub rsp, 18h
SSL_write + 0x08 | mov rax, fs:28h
SSL_write + 0x11 | xor eax, eax
SSL_write + 0x16 | test edx, edx
SSL_write + 0x.. | ...
```

```
# SSL_write с прыжком в хук

SSL_write + 0x00 | endbr64
SSL_write + 0x04 | jmp QWORD PTR payloaded_fun+0x00
SSL_write + 0x12 | endbr64
SSL_write + 0x16 | test edx, edx
SSL_write + 0x.. | ...
```

```
# Новая функция в динамически аллоцированной памяти.
# состоит из начала исходной SSL_write 
# и прыжка на продолжение SSL_write

orig_func + 0x00 | endbr64
orig_func + 0x04 | sub rsp, 18h
orig_func + 0x08 | mov rax, fs:28h
orig_func + 0x11 | xor eax, eax
orig_func + 0x16 | jmp QWORD PTR SSL_write+0x12
```


## 8.4. Логгирование
Для осуществления журналирования используются следующие самописные макросы:
```C
OSSLTRACE_LOG(...) // format, args
OSSLTRACE_LOG_BUF(buf, bufsize)
```

Может производиться как в стандартные потоки вывода (stdout/stderr), так и в файл, в зависимости от настроек пользователя. 

## 8.5. Фильтрация
Пока что фильтрация осуществляется в соответствии со списком строк, разделенных символом переноса строки; функция фильтрации ищет в передаваемом буфере одну из этих строк; если хоть одна из строк нашлась - возвращается указатель на начало найденной zero-terminated строки.

```C
char *
find_denylisted_words_occurence(const void *buf, int bufsize);
```

## 8.6. Отключение верификации цепочки доверия
Для отключения верификации цепочки доверия перехватываются вызовы SSL_set_verify() и SSL_get_verify_result(). В первом выставляем SSL_VERIFY_NONE; во втором всегда возвращаем X509_OK.

## 9. Планы
Перехват: 
- "умный" патчинг с дизассемблером (capstone)
- изучить тему eBPF (enchanced Beckerley Packet Filter)
- смешанные режимы перехвата

Подменяющие функции:
- обработка SSL_get_error: из SSL_read/write возвращается -1, но код ошибки 0; нужно исправить
- "сборка" частей сегмента в единый сегмент (SSL_pending)
- поскольку можно будет восстановить полный сегмент, реализовать более комплексный и сложный фильтр, в т.ч. для конкретных протоколов
- фильтр для http/2

Прочее:
- передача настроек не через переменные окружения (nginx их очищает)
- gnutls?
- поддержка незашифрованных соединений (обычные read, write и т.п.)?
